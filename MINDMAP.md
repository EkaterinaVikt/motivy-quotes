## Обновление раз в сутки

добудь нужный таймштамп и запиши его в константу. Сделай функцию, которая будет вызывать другие функции по рассчитанной дате (timestamp + 86400000 \* 14. 1 день равен 86400000 мс, умножаешь на нужное количество дней). Ну и когда сайт открывается, т.е. вызывается скрипт - тебе нужно, чтобы выполнилась проверка текущего timestamp с нужным, да и всё

timestamp + 86400000 == спустя сутки относительно того, во сколько ты зашёл.

А мне нужно, чтобы это выражение проверялось с тем, является ли текущее время тем же днём, в которое был получен quote и timestamp? Тогда ничего не делаем. Это новые сутки? -- тогда обновляем localStorage (получается, в 00.00)
Значит, нужно получить текущую дату. Если текущая дата равна той, что записана в штампе времени, ничего не делаем. Если текущая дата больше той, что была записана в localStorage, то тогда очищаем localStorage.
Надо поэкспериментировать с getDate().Допустим, получить метку часа. Если это тот же час, то не трогаем localStorage.

1. При клике на getQuote запрашивается текущее время timeOfQuote. Можем ли мы определить отсюда только число? Тогда можно было бы получить удобную метку, например, 1674075600000.
2. При заходе мы снова запрашиваем время currentTime
3. Далее сравниваем -- если currentTime - timeOfQuote больше, чем 86400000, значит, обновляем localStorage. Хотя так получается всё равно обновление раз в сутки. В идеале получать временную метку сегодняшнего дня в 00.00.

let timeOfGetQuote = new Date();
let dayOfGetQuote = timeOfGetQuote.getDate(); -- вот это при клике записываем в localStorage. Всё. У нас есть сегодняшнее число в localStorage, например, 19.
Далее при заходе на страницу снова выполняется функция по запросу текущей даты

let currDay = new Date();
if (currDay.getDate() > dayOfGetQuote) { localStorage.clear() }
(насколько ли это быстро и нужна ли будет крутилка?)
(сперва проверить на часах)

## Не работает компонента QuoteOfDay

она получает в пропсах дату, но отображает пустую строку, и больше дата у неё не обновляется, хотя state переписан при клике на бтн. Видимо, этот state в компоненту QuoteOfDay уже не попадает, т.к. является локальным?
Также здесь явно неправильно сделаны приходящие пропсы -- это объект, в котором Array. И, конечно, оно отображается undefined при попытке сделать props.data.

## Модальное окно

В бигбаге было реализовано через диспатч. В редьюсере определяется state для modalActive: true/false. При клике вызывалась функция, которая в свою очередь вызывала dispatch() через const dispatch = useDispatch() (нужно посмотреть документацию о нём, это библиотека react-redux).

dispatch(setModalAction(AUTH_REQUEST, true));
В редьюсере action creator выглядит так (это thunk?):
export const setModalAction = (name, activate) => (dispatch) => {
dispatch({ name, type: activate ? OPEN_MODAL : CLOSE_MODAL });
};

Получается, при нажатии вызывается функция, эта функция диспатчит нужный экшн в редьюсер, и редьюсер изменяет state.

## BLL

В Reducer есть initialState. State содержит
{ background: #fcd,
button: 'active',
quote: "";
}

Порядок действий:

1. Изначальное состояние: quote: "", btn: true, localStorage: "";
2. Кнопка нажимается
3. Срабатывает рандомайзер, выдаёт число.
4. Получаем quote. State обновляется
5. Записываем quote в localStorage
6. Обращаемся к localStorage, получаем цитату, которую туда записали
7. Выводим эту цитату на экран.

Подумать вот об этом:
React.useEffect(() => {
document.documentElement.dataset.theme = theme -- вот здесь устанавливается dataset
localStorage.setItem('theme', theme)
}, [ theme ])

## Action:

Стору (store) нужны редьюсеры (reducer), чтобы работать со стейтом (state).
